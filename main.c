/**
 ******************************************************************************
 * @file    main.c
 * @brief   EE 4065 - Embedded Digital Image Processing Homework 1
 * @author  Student
 * @date    October 2025
 ******************************************************************************
 *
 * Q1: Load grayscale image from header file and display in memory
 * Q2: Apply intensity transformations
 *     a) Negative image
 *     b) Thresholding
 *     c) Gamma correction (gamma=3 and 1/3)
 *     d) Piecewise linear transformations
 */

#include "stm32f4xx.h"
#include "image_data.h"
#include <stdio.h>
#include <math.h>

// Buffers for image processing
unsigned char original_image[IMAGE_SIZE];
unsigned char processed_image[IMAGE_SIZE];

// Q1: Display image data in memory
void display_image_in_memory(void)
{
  // Copy original image
  for (int i = 0; i < IMAGE_SIZE; i++)
  {
    original_image[i] = image_data[i];
  }

  // Display first 64 pixels (example)
  // You can observe these values in STM32CubeIDE Memory Window
  volatile unsigned char *mem_ptr = original_image;
  // Observe original_image address in memory window
}

// Q2a: Negative Image Transformation
void negative_image(unsigned char *input, unsigned char *output, int size)
{
  for (int i = 0; i < size; i++)
  {
    output[i] = 255 - input[i];
  }
}

// Q2b: Thresholding
void threshold_image(unsigned char *input, unsigned char *output, int size,
                     unsigned char threshold)
{
  for (int i = 0; i < size; i++)
  {
    output[i] = (input[i] > threshold) ? 255 : 0;
  }
}

// Q2c: Gamma Correction
void gamma_correction(unsigned char *input, unsigned char *output, int size,
                      float gamma)
{
  float c = 255.0f / powf(255.0f, gamma);

  for (int i = 0; i < size; i++)
  {
    float normalized = (float)input[i] / 255.0f;
    float corrected = powf(normalized, gamma);
    output[i] = (unsigned char)(corrected * 255.0f);
  }
}

// Q2d: Piecewise Linear Transformation
// Piecewise linear transformation for thresholding
void piecewise_linear_transformation(unsigned char *input, unsigned char *output,
                                     int size, unsigned char threshold)
{
  // Two-piece linear transformation
  // [0, threshold] -> [0, 128]
  // [threshold, 255] -> [128, 255]

  float slope1 = 128.0f / (float)threshold;
  float slope2 = 127.0f / (255.0f - (float)threshold);

  for (int i = 0; i < size; i++)
  {
    if (input[i] <= threshold)
    {
      output[i] = (unsigned char)(slope1 * (float)input[i]);
    }
    else
    {
      output[i] = (unsigned char)(128.0f + slope2 * ((float)input[i] - (float)threshold));
    }
  }
}

// Main function
int main(void)
{
  // System initialization (automatically generated by STM32CubeIDE)
  // HAL_Init();
  // SystemClock_Config();

  // Q1: Display image in memory
  display_image_in_memory();

  // Q2a: Negative Image
  negative_image(original_image, processed_image, IMAGE_SIZE);
  // Observe processed_image in memory window

  // Q2b: Thresholding (threshold = 128)
  threshold_image(original_image, processed_image, IMAGE_SIZE, 128);
  // Observe processed_image in memory window

  // Q2c: Gamma Correction (gamma = 3)
  gamma_correction(original_image, processed_image, IMAGE_SIZE, 3.0f);
  // Observe processed_image in memory window

  // Q2c: Gamma Correction (gamma = 1/3)
  gamma_correction(original_image, processed_image, IMAGE_SIZE, 1.0f / 3.0f);
  // Observe processed_image in memory window

  // Q2d: Piecewise Linear Transformation (threshold = 128)
  piecewise_linear_transformation(original_image, processed_image, IMAGE_SIZE, 128);
  // Observe processed_image in memory window

  // Infinite loop
  while (1)
  {
    // Place breakpoint here to observe results in memory window
    __NOP();
  }

  return 0;
}
